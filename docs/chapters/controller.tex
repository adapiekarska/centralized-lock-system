\chapter{Komponent sterowania zamkiem}
\label{chap:controller}

    Niniejszy rozdział zagłębia się w szczegóły implementacyjne projektu. Opisuje sposób konfiguracji środowiska deweloperskiego, przedstawia wybrane zagadnienia związane z implementacją oraz wykorzystane w projekcie technologie sprzętowe i programowe.

        Spełnienie założeń dotyczących systemu wymienionych w rozdziale \ref{chap:hl-arch} wymagało zastosowania mikrokontrolera integrującego układ komunikacji bezprzewodowej zgodnej ze zbiorem standardów IEEE 802.11, obsługującego interfejs szeregowej komunikacji z peryferiami SPI (ang. \textit{Serial Peripheral Interface}) jednocześnie umożliwiając komunikację za pośrednictwem programowalnych wejść/wyjść GPIO (ang. \textit{General-Purpose Input/Output}). Pośród wielu rozwiązań dostępnych na rynku wybrany został mikrokontroler ESP32, ze względu na możliwość równoległego przetwarzania za pomocą dwóch fizycznych rdzeni, sprzętowe wsparcie dla algorytmów kryptograficzynch oraz możliwość zaawansowanej kontroli pracy podzespołów mikrokontrolera, szczególnie w zakresie zasilania.

        Oprogramowanie dla mikrokontrolera ESP32 może być wytwarzane za pomocą środowiska Arduino. Jednakże na potrzeby projektu zdecydowano się na wykorzystanie w tym celu oficjalnego frameworka Espressif IoT Development Framework (ESP-IDF) firmy Espressif Systems. Motywacją tej decyzji była chęć uzyskania pełniejszej kontroli nad sprzętem oraz lepszego poznania mechanizmów działania systemu operacyjnego czasu rzeczywistego FreeRTOS, na którym bazuje framework ESP-IDF.

        Kryterium wyboru czytnika kart RFID była obsługa kart o częstotliwości nośnej 13,56 MHz, dostępność oprogramowania sterującego czytnikiem dla wybranego mikrokontrolera oraz obsługa interfejsu komunikacji szeregowej SPI w celu prostej integracji czytnika z mikrokontrolerem. Do tego zadania wybrany został układ MFRC522.

        Efektywne wykorzystanie energii w układzie zamka wymaga źródła impulsu wybudzającego o jak najniższym poborze mocy w stanie spoczynku. Wybranym rozwiązaniem jest czujnik PIR (ang. \textit{Passive Infra Red}, pasywny czujnik podczerwieni), model HC-SR501.

        \section{Konfiguracja środowiska}
            \textbf{TBD}

        \section{Oprogramowanie mikrokontrolera}

            \subsection{Struktura kodu}
                Kod źródłowy oprogramowania mikrokontrolera podzielony jest na komponenty o zadanych funkcjonalnościach:
                \begin{enumerate}
                    \item Komponent główny (\textit{main}): odpowiedzialny za rozróżnienie rodzajów uruchomienia (pierwsze uruchomienie lub wybudzenie z uśpienia), wywołanie odpowiedniej procedury komponentu sterującego oraz uśpienie układu po jej zakończeniu.
                    \item Komponent RFID: odpowiedzialny za inicjalizację czytnika MFRC522, wykrywanie i odczyt karty oraz sygnalizację zdarzeń związanych z odczytem kluczy dostępu do pomieszczeń.
                    \item Komponent WiFi: odpowiedzialny za realizację komumnikacji bezprzewodowej z serwerem. Obsługuje transmisje wychodzące i przychodzące wraz z opcjonalnym zestawieniem bezpiecznego kanału komunikacji z wykorzystaniem protokołu TLS.
                    \item Komponent sterujący (\textit{flow-controller}): odpowiedzialny za kontrolę przepływu sterowania, aktywowanie poszczególnych komponentów.
                \end{enumerate}

            \subsection{Współbieżność}
                Ze względu na restrykcyjne wymagania dotyczące czasu trwania procesu zestawiania połączenia z serwerem, wykorzystano przetwarzanie współbieżne na dwóch wątkach.

                \textbf{Coś o podziale zadań między taskami - TBD}

                \textbf{Diagram pokazujący jak taski między sobą się komunikują itd}

                Powiadamianie o wszystkich zdarzeniach w oprogramowaniu mikrokontrolera realizowane jest przez mechanizm tzw. \textit{Event Group}. Jest on zapewniany przez system FreeRTOS. W przypadku wystąpienia zdarzenia zostaje ono zapisane we wspomnianym wyżej \textit{Event Group}, co jest równoznaczne z ustawieniem w stan wysoki bitu przypisanego danemu zdarzeniu. Kluczowy z perspektywy przepływu sterowania jest wykorzystany mechanizm oczekiwania na zdarzenia, który przez wywłaszczenie oczekującego wątku pozwala na efektywną implementację synchronizacji wątków.

                \textbf{Dodać źródło dokumentacja FreeRTOS}

            \textbf{TBD - Przenieść część poniższych informacji na Schematy blokowe}

            \subsection{Pierwsze uruchomienie}

                Przy pierwszym uruchomienu zamka, które następuje automatycznie po podłączeniu zasilania do układu, wykonywana jest procedura przejścia w stan głębokiego uśpienia (Deep-sleep mode). W tym celu jako sposób wybudzenia konfigurowany jest tryb EXT0 (External Wakeup 0). Tryb ten wymusza aby po przejściu w stan uśpienia podtrzymane zostało zasilanie peryferiów RTC (ang. \textit{Real-Time Clock}, zegar czasu rzeczywistego)~\cite{esp32-api-ref-deep-sleep}, co z kolei pozwala na konfigurację źródła wybudzającego przerwania zewnętrznego jako wybranego wejścia RTC GPIO. W projekcie w tym celu wykorzystany został pin nr 26. Ze względu na charakterystykę wykorzystanego źródła przerwania (pasywny czujnik zbliżeniowy), konieczne było zastosowanie trybu pulldown dla wspomnianego wyżej wejścia aby zapobiec występowaniu na nim stanu nieokreślonego. Po konfiguracji źródła przerwania układ zostaje wprowadzony w stan uśpienia.

            \subsection{Wybudzenie z głębokiego uśpienia}

                \textbf{Podzielić blok tekstu na części bardziej skupiające się na poszczególnych komponentach - TBD}

                Po wykryciu ruchu, czujnik PIR generuje stan wysoki na linii wybudzającej mikrokontrolera, co wywołuje procedurę wyjścia z głębokiego uśpienia. Po wybudzeniu następuje inicjalizacja systemu obsługi zdarzeń, wykorzystywany przez wszystkie wątki jako główne narzędzie sygnalizacji postępu i synchronizacji dostępu do danych. Po przygotowaniu mechanizmu sygnalizacji zdarzeń komponent sterujący inicjuje współbieżną inicjalizację komponentów RFID oraz WiFi.

                Inicjalizacja komponentu WiFi może przebiec na dwa sposoby. Jeśli następuje po raz pierwszy od czasu podłączenia zasilania do układu, wymagane jest wykonanie konfiguracji sterownika WiFi dostarczanego przez ESP-IDF. W tym celu ustawiane są dane dostępu do sieci (SSID i hasło, osadzone w bezpośrednio w oprogramowaniu) a sterownik przestawiany jest w tryb station, pozwalający mikrokontrolerowi na nawiązanie połączenia z punktem dostępu sieci bezprzewodowej. Następnie dane konfiguracji zapisywane są w pamięci nieulotnej. Alternatywny scenariusz następuje przy każdej następnej inicjalizacji. Wykorzystuje on dane zapisane podczas poprzedniej inicjalizacji w celu odtworzenia konfiguracji sterownika WiFi.

                Wspomniana wyżej konfiguracja zostaje następnie wykorzystana do nawiązania połączenia z siecią bezprzewodową. Następnie następuje próba zestawienia bezpiecznego połączenia z serwerem, opartego na mechanizmach TLS i wzajemnego uwierzytelnienia (ang. \textit{Mutual authentication}). Po udanym zestawieniu połączenia z wykorzystaniem uścisku dłoni TLS (ang. \textit{TLS Handshake}) program przechodzi do pętli obsługi żądań transmisji pochodzących od pozostałych komponentów.

                Na listingu \ref{snip:wifi_client} przedstawiono pseudokod pętli obsługi żądań w komponencie WiFi.

                \textbf{Zmodyfikowac ten pseudokod, zeby byl bardziej czytelny i zrozumialy dla kogos nieznajacego wewnetrznej struktury i specyfiki kodu}
                \lstinputlisting[language=Python,label=snip:wifi_client,caption=Pseudokod pętli obsługi żądań w komponencie WiFi]{chapters/pseudocodes/wifi_client_pseudocode.py}

                Komponent RFID bazuje na zewnętrznej bibliotece~\cite{esp-idf-rc522}. Inicjalizacja rozpoczyna się od inicjalizacji interfejsu SPI na określonych z góry wyjściach mikrokontrolera. Następnie rozpoczyna się cykliczne odpytywanie czytnika rc522 za pomocą wspomnianego interfejsu~\cite{esp-idf-rc522}. W przypadku sygnalizacji wykrycia karty przez czytnik, pozyskiwany jest numer karty, odpytywanie zostaje zakończone a numer karty zostaje przekazany do komponentu sterującego. \textbf{TBD}

                \textbf{sterowanie po przylozeniu karty TBD}
                Po stworzeniu wątków odpowiedzialnych za wykonanie kodu komponentów WiFi i RFID komponent sterujący rozpoczyna oczekiwanie na sygnalizację wykrycia karty przez komponent RFID. Gdy to nastąpi, odczytany zostaje pozyskay numer karty. W celu wymiany danych z serwerem, wykorzystywany interfejs udostępniany przez komponent WiFi w postaci funkcji do transmisji wychodzącej i przychodzącej \textbf{dodac pseudokod funkcji żądania transmisji, uszczegółowić}. Zależnie od informacji zwrotnej od serwera, następuje przyznanie dostępu, lub jego odmowa i ponowne przejście w stan uśpienia.

    \section {Wykorzystane technologie}

        \subsection{ESP32}

            ESP32-DevKitC jest produkowaną przez firmę Espressif platformą deweloperską bazującą na module ESP32-WROOM-32D. Sercem modułu jest układ z rodziny ESP32 (ESP32-D0WD) wyposażony w CPU (ang. \textit{Central Processing Unit}, centralna jednostka obliczeniowa) o dwóch rdzeniach, z których każdy może być kontrolowany niezależnie~\cite{esp32-wroom32-ds}. Moduł integruje Bluetooth, Bluetooth Low Energy oraz WiFi, a także szeroki zakres peryferiów: czujniki dotyku, czujniki pola magnetycznego, interfejs karty SD, Ethernet, SPI, UART (ang. \textit{Universal Asynchronous Receiver-Transmitter}), I\textsuperscript{2}S (ang. \textit{Inter-IC Sound}) i I\textsuperscript{2}C (ang. \textit{Inter-Integrated Circuit})~\cite{esp32-wroom32-ds}. Dodatkowo umożliwia korzystanie z niskoenergetycznego koprocesora Ultra-Low-Power (ang. \textit{ULP co-processor}), podczas gdy główne jednostki pozostają w trybie głębokiego uśpienia~\cite{esp32-tech-ref-man}.

            ESP32 oferuje efektywną i elastyczną technologię zarządzania energią. Dokument \textit{ESP32 Series Datasheet} wymienia pięć predefiniowanychstanów energetycznych~\cite{esp32-ds}:
            \begin{enumerate}
                \item Active mode: Aktywne CPU wraz z układem radiowym, możliwa bezprzewodowa transmisja.
                \item Modem-sleep mode: Aktywne CPU z konfigurowalnym zegarem. Chip radiowy w tym trybie pozostaje wyłączony.
                \item Light-sleep mode: Uśpione CPU. Pamięć i peryferia RTC wraz z koprocesorem ULP pozostają aktywne. Jakiekolwiek zdarzenia wybudzające (MAC, host, timer RTC i zewnętrzne przerwania) doprowadzą do wybudzenia układu.
                \item Deep-sleep mode: Tylko pamięć RTC i peryferia RTC pozostają zasilone. Dane dotyczące połączeń WiFi i Bluetooth zostają przechowane w pamięci RTC. Opcjonalnie dostępny jest koprocesor ULP.
                \item Hibernation mode: Wewnętrzny rezonator kwarcowy o częstotliwośći 8~MHz wraz z koprocesorem ULP zostają wyłączone. Również pamięć RTC jest wyłączona. Wybodzenie możliwe jest tylko poprzez timer RTC lub predefiniowane wejścia RTC GPIO.
            \end{enumerate}
            Jest to szczególnie istotne z punktu widzenia wymagań dotyczących poboru energii.

        \subsection{Czytnik MFRC522}

            Do realizacji komunikacji w standardzie RFID High Frequency (13,56~MHz) wykorzystany został zintegrowany odbiornik/nadajnik MFRC522 produkowany przez firmę NXP Semiconductors, umożliwający bezprzewodową komunikację z kartami zgodnymi ze standardem ISO/IEC 14443 A/MIFARE. Układ wspiera komunikację poprzez interfejsy SPI, UART oraz I\textsuperscript{2}C~\cite{mfrc522-ds}.

        \subsection{Czujnik zbliżeniowy}
            \textbf{TBD}

    \section{Bezpieczeństwo}

        \textbf{Tutaj opisać mechanizmy wykorzystane w celu zapewnienia bezpieczeństwa systemu - TBD}

        Ważnym aspektem opracowanego systemu jest bezpieczeństwo. Bezpieczeństwo systemu tworzą następujące składowe:
            \begin{enumerate}
                \item Bezpieczeństwo zastosowanego mikrokontrolera
                \item Bezpieczeństwo komunikacji bezprzewodowej
                \item Bezpieczeństwo serwera
            \end{enumerate}

            \subsection{Bezpieczeństwo mikrokontrolerów}
                \textbf{TBD}

            \subsection{Bezpieczeństwo komunikacji bezprzewodowej}
                \textbf{TBD}

            \subsection{Bezpieczeństwo serwera}
                \textbf{TBD}


    \section{Problemy}

        Konfiguracja WiFi?
        Sygnalizacja stanu baterii?
        zarządzanie stanami energetycznymi
        Enkrypcja flash

        \subsection{Zarządzanie energią}

            \textbf{Szacunki długości życia na baterii - TBD}
            \textbf{Teoretyczne zużycie podawane w specyfikacji komponentów}
            \textbf{Pomiary poboru mocy w różnych fazach działania - TBD}